<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>ESP32_Rover_Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="assets/styles.css">
  <style>
    /* Optional: show a small on‐screen hint */
    .hint {
      text-align: center;
      margin-top: 20px;
      font-size: 1rem;
      color: #555;
    }
  </style>
</head>

<body>
  <div class="main">
    <div class="container">
      <div class="panel left">
        <div class="header">
          <h1>ESP32_Rover_Control</h1>
        </div>

        <!-- Just a hint for the user; no clickable joystick is needed now -->
        <div class="hint">
          Use <strong>W</strong>/<strong>A</strong>/<strong>S</strong>/<strong>D</strong> to drive the rover.<br>
          Hold <strong>Shift</strong> for top speed.
        </div>
      </div>

      <div class="panel right">
        <div class="data">
          <div class="controls">
            <button class="button" id="Reset_Button" onclick="resetTable()">Reset!</button>
            <button class="button" id="Read_Button" onclick="readButton()">Read!</button>
          </div>
          <table id="Data_table">
            <thead>
              <tr>
                <th>Radio</th>
                <th>Infrared</th>
                <th>Magnet</th>
                <th>Species?</th>
                <th>Ultrasound(name)</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Utility: send one fetch to the ESP32 for the given (x, y).
    function sendJoystick(x, y) {
      fetch(`/joystick?x=${x}&y=${y}`)
        .then(res => res.text())
        .then(text => console.log(`Sent x=${x}, y=${y} → Response:`, text))
        .catch(err => console.error('Fetch error:', err));
    }

    // Keep track of which WASD keys and Shift are currently held down.
    const keysDown = {
      w: false,
      a: false,
      s: false,
      d: false,
      shift: false
    };

    // Compute and send the current (x, y) based on keysDown.
    function updateDirectionFromKeys() {
      // Determine base speed: 255 if Shift is held, otherwise 100.
      const baseSpeed = keysDown.shift ? 255 : 180;

      // Compute raw directions: W→+1, S→-1; D→+1, A→-1.
      let yDir = 0;
      if (keysDown.w) yDir += 1;
      if (keysDown.s) yDir -= 1;

      let xDir = 0;
      if (keysDown.d) xDir += 1;
      if (keysDown.a) xDir -= 1;

      let x = 0;
      let y = 0;

      // If both axes are nonzero (diagonal movement), give full speed to the Y axis
      // and 60% of baseSpeed to the X axis.
      if (yDir !== 0 && xDir !== 0) {
        y = yDir * baseSpeed;
        x = xDir * Math.round(baseSpeed * 0.7);
      } else {
        // Otherwise, apply full baseSpeed to whichever axis is active.
        y = yDir * baseSpeed;
        x = xDir * baseSpeed;
      }

      sendJoystick(x, y);
    }

    // Handle keydown events for WASD and Shift.
    document.addEventListener('keydown', function (e) {
      const key = e.key.toLowerCase();

      if (['w', 'a', 's', 'd'].includes(key)) {
        // Prevent auto‐repeat spam for WASD keys.
        if (!keysDown[key]) {
          keysDown[key] = true;
          updateDirectionFromKeys();
        }
        e.preventDefault(); // avoid page scrolling or other defaults
      } else if (key === 'shift') {
        // Track Shift separately; no need to prevent default.
        if (!keysDown.shift) {
          keysDown.shift = true;
          updateDirectionFromKeys();
        }
      }
    });

    // Handle keyup events for WASD and Shift.
    document.addEventListener('keyup', function (e) {
      const key = e.key.toLowerCase();

      if (['w', 'a', 's', 'd'].includes(key)) {
        keysDown[key] = false;
        updateDirectionFromKeys();
        e.preventDefault();
      } else if (key === 'shift') {
        keysDown.shift = false;
        updateDirectionFromKeys();
      }
    });

    // If the window loses focus, treat it like “all keys up”
    window.addEventListener('blur', () => {
      let anyChanged = false;
      for (let k of ['w', 'a', 's', 'd', 'shift']) {
        if (keysDown[k]) {
          keysDown[k] = false;
          anyChanged = true;
        }
      }
      if (anyChanged) updateDirectionFromKeys();
    });

    // Your existing table‐reading logic (unchanged):
    function readButton() {
      fetch('/read_data')
        .then(response => response.text())
        .then(queryString => {
          const params = new URLSearchParams(queryString);

          const radio = params.get('radio');
          const infared = params.get('infared');
          const magnetic = params.get('magnetic');
          const species = params.get('species');
          const name = params.get('name');

          console.log('Radio:', radio);
          console.log('Infared:', infared);
          console.log('Magnetic:', magnetic);
          console.log('Species:', species);
          console.log('Name:', name);

          const table = document.querySelector("#Data_table tbody");
          const row = document.createElement("tr");

          row.innerHTML = `
            <td>${radio}</td>
            <td>${infared}</td>
            <td>${magnetic}</td>
            <td>${species}</td>
            <td>${name}</td>
          `;
          table.prepend(row);
          console.log('Table row added!');
        })
        .catch(error => {
          console.error('Error:', error);
        });
    }

    function resetTable() {
      const tbody = document.querySelector("#Data_table tbody");
      tbody.innerHTML = ''; // Removes all rows
      console.log('Table reset!');
    }
  </script>
</body>

</html>